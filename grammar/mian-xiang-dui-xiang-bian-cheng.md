# 面向对象编程

面向对象和面向过程是编程的两种思维方式，两种方式没有好坏之分，适合的情况需要使用适合的方式，python支持这两种方式。

**面向对象编程，重要的不是步骤，而是对象**

* 对象是内存中专门用来存储数据的一块区域。
* 对象是一类事物、规则、事件的集合。

对象具有状态，一个对象用数据值来描述它的状态。对象还有操作，用于改变对象的状态，对象及其操作就是对象的行为。对象实现了数据和操作的结合，使数据和操作封装于对象的统一体中。**状态：操作 == 属性：方法**。

对象是人们要进行研究的任何事物，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件。

* 通过类定义的数据结构实例。

**！类**

1. **类是对象的蓝图**；类是用来创建对象的对象。

   类是type类型的对象，定义类实际上就是定义了一个type类型的对象。

2. 类是用来描**述具有相同的属性和方法的对象的集合**。

   集合定义了由类创建的实例对象所共有的属性和方法，通过类创建的对象就是实例。

**`类`在实例化之后叫做一个`实例`**：“类”是静态的，不占进程内存，而“实例”拥有动态内存。

对象代表了类的一个特定的实例。对象具有身份（identity）、类型（type）、和属性值（attribute values）3个特征。实例是对象的具体表现，实例被用来模拟现实世界中存在的、具体的或原型的东西，由抽象走向具体。

所有的对象都是实例，但并不是所有的实例都是对象。除了类的实例外的实例都不是对象。

## **使用class来定义类**

```python
class 类名([父类]) :
    公共的属性...

    # 对象的初始化方法
    def __init__(self,...):
        ...

    # 其他的方法    
    def method_1(self,...):
        ...

    def method_2(self,...):
        ...

    ...
```

类和对象都是对现实生活中的事物或内容的抽象，事物都具备属性和方法。

* 类中定义的属性和方法都是公共的，任何该类实例都可以访问。类中属性和方法查找的**流程**：

当调用一个对象的属性时，解析器会在当前对象中查找是否含有该属性。如果有，直接返回属性值，否则去当前对象的类对象中寻找，如果有则返回类对象的属性值。

* 类对象和实例对象中都可以保存属性和方法：

如果这个**属性（方法）是所有的实例共享的，则应该将其保存到类对象中**；如果这个属性（方法）是某个**实例独有，则应该保存到实例对象中**。一般情况下，属性保存到实例对象中，而方法需要保存到类对象中。

* **self参数详解**

类中的方法被调用时，解析器都会默认首先传递一个参数给该方法。该参数是调用该方法的对象本身——一般为实例对象。一般将该参数命名为self。

```python
class Person:# 类定义的时候可以不带父类，建议类名首字母大写
    name = 'snake'

    def say(self): # self是必须的参数
        print('你好!')

p1 = Person() # 创建实例对象p1

p1.say() # p1调用say（）方法
# say方法中的self就是指p1
```

在定义类的时候方法中的参数总是比实际参数多一个，且第一个参数永远都是**self**。

## 用类实例化对象

* 类的实例化：通常把用类创建对象的过程称为实例化。

类的实例化概念，相当于**模板之余产品**。类是一个模板，类的实例化就相当于将模板制作为产品。产品可以拥有自己的特点（属性和方法），可以不与模板相同\(类\)。

```python
class Myclass(): 
    pass         # 定义了一个空的类

mc = MyClass() # mc就是通过MyClass创建的对象，mc是MyClass的实例
```

Python创建有内置对象，此前的字符串、数字、数组、字典都是内置对象，都具有其相应的类。

当我们调用数组的length方法的时候，实际上就是在调用该类型的内置方法。

创建对象的一般流程：mc = Myclass（）

* 创建变量
* 创建对象
* 把对象的地址赋值给变量——让变量指向对象。

**类与对象的关系：**

一个类可以创建多个对象，多个对象可以共享一个类。类中的属性和方法对于使用该类创建的所有对象都是**通用**的。类中的属性方法改变，所有的实例对象中的属性方法会发生对应的改变，而一个实例对象中的类和方法的改变并**不会影响**其他的对象，也不会对类造成改变。

![sd](http://twowaterimage.oss-cn-beijing.aliyuncs.com/2019-10-09-040408.png)

**slef，在类中调用类的属性**：

```python
# 创建一个自我介绍的类
class People():
    name = 'tom' 
    def say(self):
        print('Hello! My name is %s.' %self.name)

P = People()
p.say() # Hello! My name is tom.
```

## 类的重写

类中的方法称为类方法，实例对象中的方法称为实例方法，实例方法无法修改，除非直接修改实例方法的代码。

* 重写的第一方法：直接修改源代码——省时间，方便
* 重写的第一方法：补丁修改

```python
class People():
    # 创建一个类
    def say_hello(self):
        print('Hello! My name is Peter.')

# 创建一个对象
p = People()

# 创建一个用于修改类中对象的函数，当然，参数应该与原方法相一致
def run(self):
    print('I am runing!')


# 我们使用了 类.原始函数 = 新函数 就完了类方法的重写
People.say_hello = run
```

要**注意**：

这里的赋值是在替换方法，不是调用函数。所以不能加上括号，也就是**类.原始函数\(\) = 新函数\(\)** **！Wrong**

**实例方法改变对类方法不产生影响**，实例方法的改写只对实例对象产生影响。

**Python中可以动态给实例对象添加属性，不能给实例对象动态创建方法，除非使用types模块。**

```python
import types
#定义一个类
class Cat(object):
    pass

#实例话一个Cat对象
c = Cat()
#向类中动态属性
c.color = "white"
print(c.color)

def eat(self):
    print("猫在吃东西。。")

# c.eat = eat is wrong
#向类中动态添加方法
c.eat = types.MethodType(eat, c)
c.eat()
```

**types.MethodType**的第一个参数是这个函数本身，第二个参数是在调用该函数的实例对象。

**动态删除和方法**：del 对象.属性名、或者、delattr\(对象,"属性名"\)

## `__init__(self)`

初始化函数又称为构造函数，这是在类中定义的一些特殊方法。特殊方法都是以`__`开始，以`__`结束，殊方法不需要自己定义，也不需要刻意调用，特殊方法会在特殊时刻自己调用。

**特殊方法在我们将对象的id（地址）赋值给变量之前调用**：

​ 1.创建变量

​ 2.内存中创建新对象

​ 3.**init**\(self\)方法执行

​ 4.将对象的id赋值给变量

init会在对象创建以后立刻开始执行，可以初始化实例对象中的属性。用类创建对象时（对象实例化时），**类名（）里的所有参数都会依次传递到init\(\)中**，不过首先传递的还是self。

```python
class Person():
    def __init__(self,name):
        # print(self)
        # 通过self向新建的对象中初始化属性
        self.name = name
    def say(self):
        print('你好，我是%s'%self.name)

p1 = Person('张三')

print(p1.name)# 张三
p1.say()# 你好，我是张三
```

假设现在我们定义的人这个类都具有名字这个属性，并且每一个对象中的name属性基本上都是不同，我们就可以使用init来给所有对象赋值：

之前我们是将name属性在定义为对象以后，手动添加到对象中，这种方式很容易出现错误。我们希望，在创建对象时，必须设置name属性，如果不设置对象将无法创建，并且属性的创建应该是自动完成。

## 三大特性

面向对象编程拥有三大特性：封装、继承、多态。

![&#x7279;ss&#x6027;](https://images.cnblogs.com/cnblogs_com/clongge/o_OOBase.gif)

**一、封装**：隐藏对象中的属性或方法，使外部不能访问。

Python没办法做到完全隐匿信息，原因在于Python是一门解释性语言，不是汇编型语言，无法进行加密，这里说的所有的封装，都是假性，只是为了规范代码的调用。Python提供了一些方法来隐藏属性，可以在类中定义属性时使用双下划线开头，`__xxx`的方式进行隐藏。

双下划线开头的属性，是对象的隐藏属性，隐藏属性`只能`在类的内部访问，`无法`通过对象访问。隐藏属性只不过是Python自动为属性改了一个名字,实际上是将名字修改为，_**类名\`\_**_**\`属性名** 比如 `__`name -&gt; \_类名\_\_name。

**通过getter和setter方法操作封装对象中的属性。getter方法获取属性，setter方法设置属性。**

* getter 获取对象中的指定属性（get\_属性名）
* setter 用来设置对象的指定属性（set\_属性名）

通过property装饰器，可以将一个get方法转换为**对象的属性**，添加property装饰器后，我们就可以像调用属性一样使用get方法，setter方法也可以这样简化。

```python
class Person:
    def __init__(self,name,age):
        self._name = name
        self._age = age
    # 添加为property装饰器以后，我们就可以像调用属性一样使用get方法
    # 使用property装饰的方法，必须和属性名是一样的---IMPORTANT
    @property    
    def name(self):
        print('get_name方法被执行')
        return self._name

    # setter方法的装饰器：@属性名.setter
    @name.setter    
    def name(self , name):
        print('setter name方法被调用')
        self._name = name        

    @property
    def age(self):
        print('get_age方法被执行')
        return self._age

    @age.setter    
    def age(self , age):
        print('setter age方法被调用')
        self._age = age   


# 定义一个对象
p = Person('张三',18)

# 使用方法属性化来修改对象的属性
p.name = '孙悟空'# setter name方法被调用
p.age = 28# setter age方法被调用


print(p.name,p.age)
# get_name方法被执行
# get_age方法被执行
# 孙悟空 28
```

**二、继承：**通过继承可以让一个类获取到其他类中的属性和方法。

定义类时，可以在类名后的括号中指定当前类的父类（也译为超类、基类、super），子类（衍生类）可以直接继承父类中的所有的属性和方法。

```python
class Animal():
    def run(self):
        print("I will run!")

    def cry(self):
        print("I am cry!")

class Dog(Animal):
    def say(self,name):
        print("Hello! My name is %s."%name)

erha = Dog()
erha.say('erha')# Hello! My name is erha.

# 测试子类能否使用父类得方法
erha.run()# I will run! 
# 测试成功
```

在创建类时，如果省略了父类，则默认父类为object， object是所有类的父类，所有类都继承自object。 Python提供了 issubclass\(\) 检查一个类是否是另一个类的子类。

```python
a = issubclass(Animal,object)
print(a)# True
b = issubclass(Dog,Animal)
print(b)# True
# 结论：验证成功
```

**isinstance\(\)**用来检查一个对象是否是一个类的实例,如果这个类是这个对象的父类，也会返回True,所有的对象都是object的实例。

_override_方法重写：若子类中的方法和父类中方法同名，则通过子类实例去调用方法时，调用的是子类的方法。这个特点叫做方法的重写。

简单说来就是，对象调用方法得时候，首先访问创建当前对象的类，如果方法存在，直接调用；否者访问该对象的父类，如果父类中有该方法，直接调用；否者访问父类的父类（当前类的祖父类），如果有就调用，如果没有就继续往上访问，直到访问到object，如果依然没有该方法则报错。

![&#x5BF9;s&#x8C61;.PNG](https://i.loli.net/2020/02/29/IGFpLo8UjriZcda.png)

_**属性的扩展**_：父类中的所有方法都会被子类继承，包括特殊方法，当然特殊方法也可以重写。前面我们说了，属性通常放在特殊方法**init**中，所以自然，我们也可以通过重写特殊方法来达到对属性的扩展。

```python
class Dog(Animal):
    # 通常希望可以直接调用父类的__init__来初始化父类中定义的属性
    # super() 可以用来获取当前类的父类，并且通过super()方法调用父类方法时不需要传递 self
    def __init__(self,name,age):
        super().__init__(name)
        self.age = age
```

Python支持_**多重继承**_。也就是可以为一个类同时指定多个父类。在开发中没有特殊的情况，应该尽量避免使用多重继承，因为多重继承会让我们的代码过于复杂。

**实现方法**：在类名的\( \)里边添加多个类，来实现多重继承，多重继承，会使子类同时拥有多个父类，并且会获取到所有父类中的方法

**查找路径**：类名.`__bases__` 属性可以用来获取当前类的所有父类,根据父类的添加顺序作为优先级别。

三、**多态**

不同的子类对象调用相同的父类方法称为多态，多态机制使得具有不同内部结构的对象可以共享相同的外部接口。

虽然针对不同对象的具体操作方法不同，不过通过一个公共的类（父类），（那些操作）方法可以通过相同的方式调用。

**多态的作用**：让具有细微不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同功能的函数，而不用去管是否是同一个类等细节。

1、多态是调用方法的技巧，不会影响到类的内部设计；

2、只关心对象的实例方法是否同名，不关心对象所属的类型；

3、对象所属的类之间，继承关系可有可无；

4、多态的好处可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强；

**多态的具体体现**：`len()函数`

```python
l = [1,2,3]
s = 'hello'
print(len(l))
print(len(s))
```

l和s分别属于列表和字符串，而我们都可以通过len函数来计算他们的长度，却不必关心他们到底是什么类型，换句话说，只要对象中具有**len**特殊方法，就可以通过len\(\)来获取它的长度。

注释：之所以一个对象能通过len\(\)来获取长度，是因为对象中具有一个特殊方法`__len__`

## 可变对象

Python中一切都是对象，变量中存放的是对象的引用。Python的“动态类型”机制，负责检查变量的对象引用操作。动态类型机制有别于其他语言的静态类型，一个变量的类型是处在变化中的，什么时候我们才能知道该变量的类型呢？只有我们对其赋值或者对其进行引用的时候我们才能知道这个变量的类型是什么，有没有一点薛定谔的猫的感觉！

```text
1、每个对象中都保存了三个数据：
    id（标识）
    type（类型）
    value（值）    

2、列表就是一个可变对象
    a = [1,2,3]

3、a[0] = 10 （改对象）
    - 这个操作是在通过变量去修改对象的值
    - 这种操作不会改变变量所指向的对象    
    - 当我们去修改对象时，如果有其他变量也指向了该对象，则修改也会在其他的变量中体现

4、 a = [4,5,6] （改变量）
    - 这个操作是在给变量重新赋值
    - 这种操作会改变变量所指向的对象
    - 为一个变量重新赋值时，不会影响其他的变量
    - 一般只有在为变量赋值时才是修改变量，其余的都是修改对象
```

重点说一下修改对象和修改变量的区别，修改对象是对变量引用的`本身`\(即对象本身\)的修改，而修改变量是指对于`变量指向的对象`的修改。

![1.PNG](https://i.loli.net/2020/01/23/dlOcKvTIVAiB8qU.png)

对象和变量之间是有区别的：

Python通过变量修改对象

Python中若要使用变量，不需要提前声明，也不需要指定类型，只需要在用的时候，给变量赋值即可。

Python中一切都是对象，赋值的作用是让`变量指针`指向某个对象，也就是说`变量(a)`中存放着`对象的引用([1,2,3])`，而对象的引用是指向这个对象。  
例如： `a = [1,2,3]`  
分成三块来看：  
`a` 变量，变量名为a  
`=` 赋值，使a指向`[1,2,3]`  
`[1,2,3]` 对象，可以通过a来进行引用

```python
 # 修改列表：
 a = [1,2,3]
print('修改前：', a , id(a))#修改前： [1, 2, 3] 2659098571080

a[0] = 10
print('修改后：', a , id(a))#修改后： [10, 2, 3] 2659098571080

可以看出修改列表之后列表的id并没有发生变化，通过该方法可以修改对象的值（value）。
```

通过`a[0] = 10` （修改对象值）

* a\[0\] = 10 （修改对象值）  
  * 作用：通过变量去修改对象的值  
  * 效果：不会改变变量所指向的对象      

    ![2.PNG](https://i.loli.net/2020/01/23/UHpIGegu1iobCE4.png)

    我们可以看到a和b的id是一样的，说明，此时a和b指向的对象是同一个。

  * 当我们去修改对象时，如果有其他变量也指向了该对象，则修改也会在其他的变量中体现。

通过`b = [10,2,3]`（修改变量指针）

* b = \[10,2,3\]（修改变量指针） 
  * 作用：给变量重新赋值  
  * 结果：会改变变量所指向的对象  

    ![3.PNG](https://i.loli.net/2020/01/23/WLp2oBAZXCjwzs5.png)

  * 为一个变量重新赋值时，不会影响其他的变量

